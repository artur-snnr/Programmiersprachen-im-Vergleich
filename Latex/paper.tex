\documentclass[10pt,twocolumn]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}   
\usepackage{lipsum}          
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{amsmath, amssymb}
\usepackage[
    backend=biber,
    style=numeric,
]{biblatex}
\addbibresource{literatur.bib} 
\usepackage{csquotes}

\usepackage[a4paper,margin=2cm]{geometry}

\title{Programmiersprachen im Vergleich}
\author{Artur Papoyan}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Rust is a modern systems programming language that was designed to address long-standing safety and 
reliability issues in low-level software development. Traditional systems languages such as C and C++ 
provide fine-grained control over memory and hardware, but they also allow many classes of errors, especially 
memory safety violations and data races, which are difficult to detect and debug. Rust approaches this 
problem by enforcing strict safety guarantees at compile time while avoiding a garbage collector. Its 
core mechanisms, such as ownership, borrowing, and a strong static type system, aim to prevent undefined 
behavior without sacrificing performance. In recent years, Rust has gained significant adoption in both industry and 
academia, and its claims of memory safety and “fearless concurrency” have been the 
subject of formal and empirical analysis. This paper presents an overview of Rust's design principles, language 
features, and ecosystem, and discusses how these aspects support safe and efficient systems 
programming\cite{matsakis2014ownership,rustbook,jung2018rustbelt}.
\end{abstract}

\section{Introduction}
\paragraph{Motivation}
Systems software forms the foundation of modern computing, including operating systems, browsers, network services, 
and embedded systems. Errors in such software can have severe consequences, ranging from security vulnerabilities to 
system crashes. A large portion of these problems is caused by memory safety issues such as use-after-free 
errors, buffer overflows, and data races. Languages like C and C++ offer high performance and direct control 
over system resources, but they provide only limited built-in mechanisms to prevent these errors. As a result, correctness heavily depends on developer discipline and extensive testing.

Rust was created to address this situation by combining low-level control with strong compile-time safety guarantees. 
Its design is based on the idea that many common programming errors can be ruled out statically, before the program 
is executed. In particular, Rust focuses on memory safety without relying on a garbage collector and on preventing 
data races in concurrent programs. These goals are achieved through a combination of language features, most notably 
ownership, borrowing, and a strict type system\cite{matsakis2014ownership,rustbook}. Over time, these 
ideas have been formalized and evaluated, for example through the RustBelt project, which provides a soundness 
argument for Rust's core safety guarantees\cite{jung2018rustbelt}. More recent work has examined whether 
Rust's promise of safe and efficient concurrency holds in practice, especially for parallel programs\cite{abdi2024fearless}.


\paragraph{Overview of the paper structure}
The remainder of this paper is structured as follows. The first part introduces the origins of Rust and its design philosophy, 
including its historical background and the role of its governing organizations. This is followed by a discussion of Rust's 
ownership and borrowing model, which forms the foundation of its memory safety guarantees. The next part explains how Rust 
manages memory without the use of a garbage collector and contrasts this approach with garbage-collected languages. 

Afterwards, the paper focuses on concurrency and synchronization in Rust, covering concepts such as fearless concurrency, 
zero-cost abstractions, and the role of traits like \texttt{Send} and \texttt{Sync}. The subsequent part presents important 
characteristics of Rust's type system and its mechanisms for error handling. The tooling and ecosystem surrounding Rust, including the package manager and documentation infrastructure, are then outlined. 

Finally, the paper will present the practical part of this work and conclude with a summary of the main findings and limitations\cite{rustbook,abdi2024fearless}.

\section{Rust Highlights}

Rust is designed as a systems programming language that combines low-level control with strong safety guarantees. Its 
main distinguishing features are not individual syntax elements, but rather a set of design principles that influence 
the entire language. These principles aim to reduce common programming errors while preserving performance comparable to 
traditional systems languages. Many of Rust's highlights are closely connected and build upon each other, especially in 
the areas of memory management, concurrency, and type safety\cite{matsakis2014ownership,rustbook}.


\subsection{Origin and Design Philosophy}

\paragraph{History and Background}
Rust was originally developed as a personal project by Graydon Hoare in 2006. The language was later adopted and officially 
supported by Mozilla, where it evolved into a larger open-source project. The initial motivation behind Rust was to address 
recurring problems observed in large systems software, particularly memory safety errors and concurrency bugs, which were 
common in existing low-level languages such as C and C++\cite{matsakis2014ownership,rustwikipedia}.

From its early stages, Rust was designed with a strong focus on safety enforced at compile time rather than at runtime. 
This approach was intended to prevent entire classes of errors before a program is executed. Over several years of 
development, Rust's design was refined through community feedback and practical experience. The first stable release, 
Rust 1.0, marked a point where the language was considered mature enough for production use, while still continuing 
to evolve in later versions\cite{rustbook,rustwikipedia}.

An important aspect of Rust's history is its transition from a research-driven project to a widely used industrial
language. While Mozilla played a central role in its early development, Rust gradually became governed by a broader 
community and formal organizational structures. This evolution reflects Rust's growing relevance beyond experimental 
settings and highlights its ambition to serve as a general-purpose systems programming language with strong safety guarantees\cite{rustbook,rustwikipedia}.

\paragraph{Goal: Memory Safety without Garbage Collector}
One of the central goals of Rust's design is to provide strong memory safety guarantees without relying on a 
garbage collector. Traditional garbage-collected languages simplify memory management by automatically reclaiming unused 
memory at runtime, but this often introduces runtime overhead and unpredictable pauses. Rust deliberately avoids this approach 
in order to remain suitable for systems programming, where predictable performance and low-level control are essential\cite{matsakis2014ownership,rustbook}.

Instead of a garbage collector, Rust enforces memory safety through compile-time rules based on ownership and borrowing. 
These rules ensure that each value has a clear owner and that memory is released deterministically when this owner goes out of scope. 
By shifting memory management decisions to compile time, Rust aims to eliminate common errors such as use-after-free and double-free 
bugs while maintaining performance comparable to languages like C and C++\cite{matsakis2014ownership,jung2018rustbelt}. This design 
choice reflects Rust's broader philosophy of preventing errors early, rather than detecting them at runtime.

\paragraph{Role of the Rust Foundation}
As Rust grew from an experimental project into a widely used programming language, its governance structure also evolved. Today, 
the development of Rust is supported by the Rust Foundation, which provides organizational and legal backing for the language and its 
ecosystem. The foundation's role is to ensure the long-term sustainability of Rust by supporting its open-source development and 
coordinating contributions from industry and the community\cite{rustbook,rustwikipedia}.

The Rust Foundation does not control the technical direction of the language in a centralized manner. Instead, Rust continues to be 
developed through open processes involving working groups and community discussion. This governance model reflects Rust's origins as 
a community-driven project and helps balance stability with continued innovation. By separating technical decision-making from legal
and organizational responsibilities, the Rust Foundation supports the ongoing evolution of the language while preserving its core design principles\cite{rustbook,rustwikipedia}.

\subsection{Ownership and Borrowing}

\paragraph{Ownership model: who owns what?}
The ownership model is a central concept in Rust and forms the basis of its memory safety guarantees. In Rust, every value has exactly 
one owner at any point in time. The owner is responsible for the value and determines when the associated memory is released. When the 
owner goes out of scope, the value is automatically dropped and its memory is deallocated. This rule ensures that memory is freed exactly 
once and prevents errors such as double frees and use-after-free bugs\cite{matsakis2014ownership,rustbook}.

Ownership can be transferred, for example when a value is passed to a function or assigned to another variable. After such a move, the 
previous owner can no longer access the value. By enforcing these rules at compile time, Rust guarantees that there is always a clear 
and unambiguous responsibility for each piece of memory. This approach replaces manual memory management patterns commonly found in C 
and C++ with a statically checked discipline\cite{matsakis2014ownership,jung2018rustbelt}.

\paragraph{Borrowing: shared and exclusive references}
While strict ownership rules provide safety, they would be too restrictive for practical programming without additional mechanisms. 
Rust therefore introduces borrowing, which allows temporary access to a value without transferring ownership. Borrowing is expressed 
through references, which can be either shared or exclusive. Shared references allow multiple readers to access a value at the same 
time, but they do not permit mutation. Exclusive references allow mutation, but only one such reference may exist at a time\cite{rustbook}.

This distinction between shared and exclusive references enforces the principle that aliasing and mutation cannot occur simultaneously. 
By preventing mutable aliasing, Rust eliminates data races in safe code. These rules are checked entirely at compile time and do not 
introduce runtime overhead. Borrowing therefore enables flexible access to data while preserving the guarantees required for memory 
and thread safety\cite{matsakis2014ownership,jung2018rustbelt}.

\paragraph{Borrow Checker and lifetimes}
The enforcement of ownership and borrowing rules is performed by the Rust compiler component known as the borrow checker. The borrow 
checker analyzes the program to ensure that all references are valid and that they do not outlive the data they refer to. To achieve 
this, Rust uses the concept of lifetimes, which describe the scope during which a reference is valid\cite{rustbook}.

Lifetimes are usually inferred automatically by the compiler, allowing programmers to write code without explicitly annotating 
them in most cases. When necessary, explicit lifetime annotations make the relationships between references clear and verifiable. 
Through this analysis, the borrow checker guarantees that references never become dangling and that memory safety is preserved. 
The soundness of this approach, even in the presence of certain unsafe abstractions, has been formally studied and justified in prior work\cite{jung2018rustbelt}.


\subsection{Memory Management Without Garbage Collector}

\paragraph{Automatic deallocation via scope-based drop}
Rust manages memory without using a garbage collector by relying on deterministic, scope-based deallocation. This mechanism 
is closely tied to the ownership model. Each value in Rust has a single owner, and when this owner goes out of scope, the value is 
automatically dropped. During this drop operation, Rust releases the associated resources, including heap-allocated memory\cite{rustbook,matsakis2014ownership}.

This approach allows memory to be reclaimed at well-defined points in the program, without the need for runtime tracing or 
background cleanup. Because deallocation is determined statically by the program structure, Rust avoids unpredictable pauses that are 
common in garbage-collected systems. At the same time, the compiler ensures that values are dropped exactly once, which prevents memory 
errors such as double frees and dangling pointers\cite{jung2018rustbelt}. As a result, Rust achieves memory safety while keeping memory management explicit and predictable.

\paragraph{Comparison to Garbage Collector}
In garbage-collected languages, memory management is typically handled by a runtime system that periodically identifies and frees 
unused objects. While this simplifies programming, it introduces additional runtime overhead and can make performance behavior less 
predictable. Rust deliberately avoids this model in order to remain suitable for systems programming, where control over performance and 
resource usage is important\cite{rustbook,matsakis2014ownership}.

By enforcing memory safety through compile-time checks instead of runtime garbage collection, Rust shifts responsibility 
from the runtime system to the compiler. This design reduces runtime costs and allows Rust programs to achieve performance comparable to 
traditional systems languages. At the same time, formal analyses have shown that Rust's approach can provide strong safety guarantees, even in the presence of 
low-level abstractions, as long as the language's rules are respected\cite{jung2018rustbelt}.

\subsection{Concurrency and Synchronization}

\paragraph{Fearless Concurrency}
Concurrency is one of the main areas where Rust aims to improve over traditional systems programming languages. The Rust documentation 
introduces this goal under the term “fearless concurrency,” which describes the idea that many concurrency errors should be detected 
at compile time rather than at runtime. In Rust, the same ownership and borrowing rules that ensure memory safety are also used to prevent data races in concurrent programs\cite{rustbook}.

In safe Rust code, it is not possible for multiple threads to have unsynchronized mutable access to the same data. This eliminates data races by construction. As a result, 
programmers can write concurrent code with stronger guarantees that certain classes of errors cannot occur. However, recent empirical studies have shown that while Rust 
effectively prevents data races, it does not eliminate all concurrency-related challenges, especially in more complex parallel patterns\cite{abdi2024fearless}.

\paragraph{Safety + Performance}
Rust's approach to concurrency is closely tied to its performance goals. Instead of relying on runtime checks or a virtual machine, Rust enforces safety 
properties at compile time. This design avoids runtime overhead while still providing strong guarantees. As a result, Rust programs can achieve performance 
comparable to C and C++ while offering stronger safety properties\cite{matsakis2014ownership,rustbook}.

Formal and empirical analyses have shown that Rust's safety mechanisms do not inherently require performance trade-offs. In many cases, safe 
abstractions compile down to efficient machine code. However, when programmers need to express more irregular parallelism, they may have to rely on 
synchronization primitives or unsafe code, which can reintroduce complexity and potential performance costs\cite{abdi2024fearless,jung2018rustbelt}.

\paragraph{Zero-Cost Abstractions}
A key principle in Rust's design is the use of zero-cost abstractions. This means that high-level language features should not impose additional runtime 
overhead compared to equivalent low-level code written manually. In the context of concurrency, this principle allows developers to use safe abstractions for 
threading and synchronization without paying a performance penalty\cite{rustbook}.

Zero-cost abstractions rely on the compiler's ability to optimize away abstraction layers during compilation. Rust's type system and ownership model 
provide the necessary information for these optimizations. As a result, concurrency constructs in Rust can be both expressive and efficient, as long as 
they remain within the guarantees enforced by the type system\cite{matsakis2014ownership}.

\paragraph{Send/Sync}
Rust uses marker traits to express thread-safety properties at the type level. The two most important traits in this context are~\texttt{Send} and~\texttt{Sync}. 
A type that implements \texttt{Send} can be safely transferred between threads, while a type that implements \texttt{Sync} can be safely shared between 
threads through references. These traits are checked at compile time and form the basis of Rust's concurrency guarantees\cite{rustbook}.

Most primitive types in Rust implement these traits automatically, while more complex types may not. This ensures that only data structures that 
are safe to use in concurrent contexts can be shared or transferred between threads. By encoding these properties in the type system, 
Rust prevents many common concurrency errors before the program is executed\cite{jung2018rustbelt}.

\paragraph{Threads, Channels}
Rust provides basic concurrency primitives such as threads and message-passing channels through its standard library. Threads allow multiple units 
of execution to run in parallel, while channels provide a safe way to communicate between threads without shared mutable state. Communication 
through channels follows the ownership model, as values are transferred from sender to receiver\cite{rustbook}.

This message-passing approach reduces the need for shared mutable data and simplifies reasoning about concurrent programs. By combining threads with 
channels and ownership-based transfers, Rust encourages designs that avoid data races and make synchronization explicit and verifiable at compile time\cite{matsakis2014ownership}.

\paragraph{async/await and runtime ecosystem}
In addition to thread-based concurrency, Rust supports asynchronous programming through the \texttt{async} and \texttt{await} keywords. These features 
allow programmers to write non-blocking code in a sequential style. Asynchronous tasks are managed by runtime systems that schedule and execute them efficiently\cite{rustbook}.

Rust's asynchronous model integrates with its ownership and type system, ensuring that memory safety and data race freedom are preserved even in asynchronous contexts. 
While the language itself provides the core syntax, the execution model is implemented by external runtime libraries. This separation allows flexibility in choosing 
different runtime implementations while maintaining the same safety guarantees\cite{rustbook,abdi2024fearless}.


\subsection{Type System and Language Characteristics}

\paragraph{Static typing}
Rust is a statically typed programming language. This means that the types of all variables and expressions are known at compile time. 
Static typing allows the compiler to detect many classes of errors early, before the program is executed. In Rust, type checking works 
together with the ownership and borrowing rules to ensure memory safety and prevent invalid operations\cite{rustbook,matsakis2014ownership}.

Although Rust is statically typed, it reduces verbosity through type inference. In many cases, the compiler can infer types automatically, 
which keeps code readable while still benefiting from strong static guarantees. This balance allows Rust to 
combine safety with practical usability in large systems programs\cite{rustbook}.

\paragraph{Traits and Generics}
Rust uses traits to define shared behavior across different types. A trait specifies a set of methods that a type must implement. 
This mechanism is similar to interfaces in other languages, but it is deeply integrated into Rust's type system. Traits are widely
used to express abstraction and to enable code reuse without relying on inheritance\cite{rustbook}.

Generics allow functions, structs, and enums to operate on multiple types while preserving static type safety. When generics 
are used together with traits, Rust can enforce constraints on type parameters at compile time. This design enables flexible 
and reusable code without introducing runtime overhead, which is consistent with Rust's zero-cost abstraction principle\cite{matsakis2014ownership}.

\paragraph{Pattern Matching}
Pattern matching is an important language feature in Rust that allows values to be compared against structured patterns. It is 
commonly used with enums and other composite types to handle different cases explicitly. Pattern matching helps ensure that 
all possible cases are considered, which improves program correctness\cite{rustbook}.

The compiler checks pattern matches for exhaustiveness, meaning that missing cases are detected at compile time. This behavior reduces the 
likelihood of unhandled states and makes control flow more explicit. As a result, pattern matching supports Rust's overall goal of preventing errors through static analysis\cite{rustbook}.

\paragraph{Error handling: Result, Option}
Rust uses explicit types for error handling instead of exceptions. The \texttt{Option} type represents the presence or absence of a value, 
while the \texttt{Result} type represents either a successful outcome or an error. By encoding these possibilities in the type system, Rust forces programmers to handle error cases explicitly\cite{rustbook}.

This approach makes error handling visible in function signatures and prevents errors from being silently ignored. Combined with pattern matching, 
\texttt{Option} and \texttt{Result} encourage robust and predictable error handling strategies. This design aligns 
with Rust's emphasis on safety and explicitness, especially in systems-level code\cite{rustbook}.

\subsection{Tooling and Ecosystem}

\paragraph{Cargo (Package Manager and Build System)}
Rust provides an integrated build system and package manager called Cargo. Cargo is used to manage dependencies, compile projects, 
run tests, and build documentation. It standardizes common development tasks and reduces the need for external tools or custom build scripts. 
By providing a single, unified interface, Cargo simplifies project setup and improves reproducibility across different systems\cite{rustbook}.

Cargo also enforces a conventional project structure, which makes Rust projects easier to understand and maintain. This standardization supports 
collaboration and lowers the entry barrier for new developers. The tight integration between the language and its tooling is a key aspect of Rust's ecosystem\cite{rustbook}.

\paragraph{Crates.io (Ecosystem)}
Crates.io is Rust's official package registry and hosts reusable libraries, known as crates. These crates can be easily added as dependencies using Cargo. 
The registry plays a central role in Rust's ecosystem by enabling code reuse and sharing across projects\cite{rustbook}.

The ecosystem includes libraries for a wide range of tasks, including networking, concurrency, and data processing. Many of these libraries rely on Rust's 
safety guarantees and use interior abstractions to provide safe interfaces. This ecosystem supports Rust's adoption in both experimental and production settings\cite{rustbook}.

\paragraph{rustup and Toolchains}
Rustup is a tool for managing Rust toolchains and compiler versions. It allows developers to install, update, and switch between different 
versions of the Rust compiler. This is particularly useful for testing code against multiple compiler releases or using nightly features when required\cite{rustbook}.

By separating the compiler from the system environment, rustup supports consistent development workflows across platforms. It also 
simplifies access to additional tools provided by the Rust project, such as formatting and linting utilities\cite{rustbook}.

\paragraph{rustdoc, Testing, Benchmarking}
Rust includes built-in support for documentation generation through rustdoc. Documentation comments written in the source code are 
converted into structured HTML documentation. This encourages developers to document APIs as part of the development process\cite{rustbook}.

Testing is also integrated into the language and tooling. Cargo provides commands to run unit tests and integration tests, which 
are written using standard Rust syntax. This integration supports test-driven development and helps ensure correctness. Benchmarking
support is available through dedicated tools, allowing developers to measure performance in a controlled way\cite{rustbook}.

\subsection{Current Developments}
Rust continues to evolve through an open and community driven development process. New language features and improvements are 
introduced carefully, with a strong focus on backward compatibility and stability. This approach allows Rust to grow while preserving the guarantees that existing code relies on\cite{rustbook,rustwikipedia}.

Current development efforts focus on improving usability, expanding the standard library, and refining existing features. 
At the same time, research continues to analyze and formalize Rust's safety guarantees, particularly in areas such as concurrency and unsafe abstractions\cite{jung2018rustbelt,abdi2024fearless}.

\subsection{Comparison with Other Languages}

\paragraph{Rust vs. C++}
Rust and C++ are both used for systems programming and provide low-level control over memory and performance. However, they 
differ significantly in how safety is enforced. In C++, memory safety and data race freedom depend largely on programmer 
discipline and runtime testing. Rust, in contrast, enforces strict safety rules at compile time through its ownership and type system\cite{matsakis2014ownership,jung2018rustbelt}.

While both languages can achieve similar performance, Rust aims to prevent entire classes of errors before execution. Studies 
have shown that Rust's approach can significantly reduce memory-related bugs, although complex concurrency patterns may still 
require careful design and, in some cases, unsafe code\cite{abdi2024fearless}. As a result, Rust represents a different trade-off between control, safety, and complexity compared to C++\cite{rustbook}.

\section{Practical Implementation}

The practical part of this work is the implementation of a simplified text search tool that recursively scans files and directories for a given regular expression. The program supports features such as contextual output, optional colored highlighting, and configurable handling of hidden files. The implementation serves as a concrete example to evaluate how Rust's language design and ecosystem support the development of a small but non-trivial systems program.

One of the most noticeable aspects during implementation was the strong support provided by Rust's standard library. Core functionality such as file access, buffered input, directory traversal, and command-line argument handling is available without relying on platform-specific APIs. These abstractions are designed to be safe by default, which reduces the likelihood of common programming errors. At the same time, they remain close enough to the underlying system interfaces to allow fine-grained control when needed\cite{rustbook}.

Rust's type system influenced the structure of the program in a practical way. Many operations that may fail, such as opening files or reading directory entries, are represented explicitly in the types returned by library functions. This forces error handling decisions to be made deliberately and locally, rather than being deferred implicitly. As a result, failure cases become part of the program's control flow and are easier to reason about. This explicit style aligns with Rust's general design goal of making potentially unsafe situations visible at compile time\cite{rustbook}.

The ownership model also affected the organization of the code, particularly in functions that process file contents and context lines. Data is passed between functions in a way that clearly defines which part of the program is responsible for it at any moment. Temporary buffers and intermediate results are dropped automatically when they are no longer needed. This allows deterministic resource management without manual memory handling, while still avoiding runtime garbage collection\cite{matsakis2014ownership}. In practice, this made it easier to reason about resource lifetimes, especially when working with nested directory structures and multiple files.

External libraries were integrated through Rust's package management infrastructure. The regular expression functionality used in the program is provided by a reusable library obtained via the official package registry. Cargo handles dependency resolution, compilation, and integration automatically. This tight coupling between language and tooling reduces setup effort and helps maintain a clear project structure. From a practical perspective, this makes experimenting with additional functionality straightforward, while keeping builds reproducible\cite{rustbook}.

Although the program itself is sequential, Rust's concurrency model still influenced design decisions. Shared mutable state was avoided by structuring the code around local processing and clearly scoped data. This matches Rust's philosophy of preventing data races by construction. Even without explicit parallelism, the guarantees enforced by the compiler make it easier to reason about potential future extensions, such as parallel file processing, without fundamentally restructuring the code\cite{abdi2024fearless}.

Overall, the practical implementation confirms several observations made in the theoretical part of this work. Rust provides strong guidance through its type system and standard library, which shapes program structure toward safe and explicit designs. While this requires the developer to engage with the language's constraints, it also reduces ambiguity and hidden behavior. These characteristics are consistent with formal and empirical analyses of Rust's safety goals and demonstrate how they manifest in everyday systems programming tasks\cite{jung2018rustbelt,rustbook}.


\section{Conclusion}

This paper examined the Rust programming language from both a theoretical and a practical perspective. The goal was to understand how Rust addresses common problems in systems programming and how its design choices affect real-world software development. By combining a discussion of Rust's core concepts with a practical implementation, this work provides a structured overview of Rust's strengths, limitations, and intended use cases.

At the theoretical level, Rust was shown to be strongly centered around memory safety without the use of a garbage collector. Its ownership and borrowing model enforces strict rules about how data can be accessed and modified. These rules are checked at compile time and prevent many classes of memory errors, such as use-after-free and double-free bugs. Formal work such as RustBelt demonstrates that these guarantees are not only intuitive design goals, but can also be justified rigorously, even in the presence of low-level abstractions\cite{jung2018rustbelt}. This places Rust in a unique position among systems programming languages.

Another central theme of this work was concurrency. Rust promotes the idea of “fearless concurrency” by using the same ownership and type-based rules to prevent data races. In safe Rust code, unsynchronized shared mutable access is not possible, which eliminates an important source of concurrency bugs. However, recent empirical studies show that while Rust effectively prevents data races, it does not remove all challenges related to parallel programming. More complex access patterns and irregular parallelism still require careful design and, in some cases, the use of synchronization primitives or unsafe code\cite{abdi2024fearless}. This highlights that Rust improves safety, but does not eliminate the inherent complexity of concurrent systems.

The discussion of Rust's type system further showed how safety and expressiveness are combined. Static typing, traits, generics, and pattern matching contribute to making program behavior explicit and verifiable. Error handling through types such as \texttt{Result} and \texttt{Option} encourages developers to deal with failure cases explicitly. These mechanisms support Rust's broader philosophy of making potential errors visible early, rather than hiding them behind implicit runtime behavior\cite{rustbook}.

The practical implementation of a search tool served as a concrete example of how these concepts influence everyday programming. Rather than focusing on implementation details, the practical part demonstrated how Rust's language features guide program structure. Ownership and explicit error handling shaped how data and failures were handled, while the standard library and tooling ecosystem simplified interaction with the file system and external libraries. The use of Cargo and crates from the official registry showed how Rust integrates language and tooling in a coherent way, reducing setup complexity and supporting reproducible builds\cite{rustbook}.

One important observation from the practical work is that Rust encourages deliberate design decisions. The compiler enforces constraints that may initially slow down development, especially for programmers new to the language. However, these constraints also reduce ambiguity and hidden behavior. As a result, the final program benefits from stronger guarantees about correctness and resource usage. This confirms Rust's goal of shifting effort from debugging runtime errors to reasoning at compile time\cite{matsakis2014ownership}.
At the same time, this work also highlights limitations. Rust's strict rules can make certain programming patterns harder to express, particularly in advanced concurrent scenarios. While unsafe code and synchronization primitives provide escape hatches, they reintroduce some of the risks that Rust aims to avoid. This aligns with existing research, which shows that Rust improves safety but cannot fully remove the challenges of complex parallel systems\cite{abdi2024fearless}. Therefore, Rust should be seen as a language that reduces, but does not eliminate, the need for careful system design.

In summary, Rust represents a significant step forward in systems programming language design. Its combination of compile-time safety guarantees, predictable performance, and a strong ecosystem makes it a compelling alternative to traditional languages such as C and C++. The results of this work support the view that Rust's design principles are not only theoretically sound, but also practically relevant. At the same time, Rust remains a language that requires expertise and careful thinking, especially in advanced use cases. These trade-offs define Rust's role as a modern systems programming language that prioritizes safety without abandoning control\cite{rustbook,jung2018rustbelt}.

\printbibliography
\end{document}
