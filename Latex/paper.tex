\documentclass[10pt,twocolumn]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}   
\usepackage{lipsum}          
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{amsmath, amssymb}
\usepackage[
    backend=biber,
    style=alphabetic,
]{biblatex}
\addbibresource{literatur.bib} 
\usepackage{csquotes}

\usepackage[a4paper,margin=2cm]{geometry}

\title{Programmiersprachen im Vergleich}
\author{Artur Papoyan}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
\end{abstract}

\section{Introduction}
\begin{itemize}
    \item Motivation 
    \item Overview of the paper structure
\end{itemize}
    
\section{Rust Highlights}
\subsection{Origin and Design Philosophy}

\subsubsection{History and Background}

Rust's creation was driven by the goal of overcoming the apparent trade-off between safety and control in programming languages. Graydon Hoare began developing Rust in 2006 (as a side project at Mozilla), and Mozilla officially sponsored the project by 2009. After years of open development and community input, Rust 1.0 was released in 2015. From the outset, Rust's design philosophy has focused on providing memory safety without a garbage collector and concurrency safety without data races, all while preserving the performance of low-level programming. In other words, Rust aspires to give developers the “bare metal” control of C/C++ with far fewer chances to shoot themselves in the foot.

\subsubsection{Goal: Memory Safety without Garbage Collector}

A core tenet of Rust's philosophy is to enforce memory safety statically (at compile time) rather than through runtime checks. Rust features a strong static type system and an ownership model that together enforce strict safety guarantees. Common causes of bugs in C/C++ (such as dangling pointers, double frees, or buffer overflows) are prevented in Rust by design, because the language rules simply disallow those dangerous patterns in safe code. If needed, Rust does permit escaping the strict rules via an \texttt{unsafe} keyword (for instance, to interface with low-level hardware or optimize a critical routine), but unsafe blocks are explicitly marked and encapsulated, and the programmer must then ensure safety manually. Even with this escape hatch, the overall approach is that safe Rust code is memory-safe and free of undefined behavior. This approach has been successful: Rust has quickly gained a reputation for reliability and has been adopted in domains like operating system kernels, browser engines, and even space systems software where reliability is paramount.

Memory safety in Rust is achieved without using a garbage collector, which is a distinguishing aspect of its design. Instead of automatic garbage collection, Rust uses deterministic memory management through its ownership system. This eliminates the runtime overhead of a GC and avoids nondeterministic pauses, while still preventing use-after-free and other memory errors at compile time. The language also emphasizes zero-cost abstractions, meaning that higher-level constructs (like generics, iterators, traits, or async functions) compile down to code that is as efficient as hand-written low-level C code.

\subsubsection{Role of the Rust Foundation}

To ensure the long-term sustainability of the language and community, the Rust Foundation was established in 2021. This independent organization took over the stewardship of Rust from Mozilla and now oversees the language's governance, development, and ecosystem. Backed by companies like Amazon, Microsoft, and Google, the foundation provides organizational support and helps guide the future direction of Rust. This move has helped strengthen trust in Rust's longevity, especially in industries that require long-term support and stability in their development tools.


\subsection{Ownership and Borrowing}
\begin{itemize}
\item Ownership model: who owns what?
\item Borrowing: shared and exclusive references
\item Borrow Checker and lifetimes
\end{itemize}

\subsection{Memory Management Without Garbage Collector}
    Unlike many high-level languages, Rust achieves memory safety without a garbage collector. Memory is managed through the ownership system described above. When an object's lifetime ends, its memory is immediately freed by Rust's runtime (through an automatic call to its destructor, if it has one) at the end of the scope. This approach yields deterministic memory management: the programmer (and compiler) know exactly when an object will be deallocated, which is typically when it goes out of scope. There is no need to wait for a garbage collector to periodically find and reclaim unused memory. As a result, Rust programs avoid the runtime overhead of GC pauses and can often use memory more efficiently.

    To illustrate, consider a simple example: if you allocate a buffer inside a function in Rust (e.g., by creating a Vec<u8> inside the function), that buffer's memory will be freed as soon as the function returns and the vector goes out of scope. This is done automatically by Rust's standard library implementation of Vec in its Drop trait. The programmer does not have to manually free the memory (as in Cs free()), nor worry about a garbage collector cleaning it up eventually, the cleanup happens immediately when it should. The strict ownership rules ensure that there are no dangling pointers to that buffer at the time of deallocation, because the compiler would not allow those pointers to exist beyond the scope.


In summary, Rust's memory management can be seen as an automated scope-based memory management (similar to C++ RAII) with compile-time checks to ensure safety. This approach contrasts with garbage-collected languages where memory safety is attained by automatic tracing and collection (with potential runtime costs and nondeterministic timing) and with traditional C/C++ where manual memory management can be efficient but error-prone. Rust manages to largely “have its cake and eat it too”  memory safety without garbage collection, and performance without sacrificing safety. As a result, Rust is particularly attractive for systems programming tasks where predictable performance and low-level control are required, but one also wants to avoid the memory errors that have historically caused security vulnerabilities in C/C++ software.
\begin{itemize}
\item Automatic deallocation via scope-based drop
\item Comparison to Garbage Collector
\end{itemize}


\subsection{Concurrency and Synchronization}
\begin{itemize}
\item Fearless Concurrency
\item Safety + Performance
\item Zero-Cost Abstractions
\item Send/Sync
\item Threads, Channels
\item async/await + runtime ecosystem
\end{itemize}

\subsection{Type System and Language Characteristics}
\begin{itemize}
\item Static typing
\item Traits and Generics
\item Pattern Matching
\item Error handling: Result, Option
\end{itemize}

\subsection{Tooling and Ecosystem}
\begin{itemize}
\item Cargo (Package Manager and Build System)
\item Crates.io (Ecosystem)
\item rustup and Toolchains
\item rustdoc, Testing, Benchmarking
\end{itemize}

\subsection{Current Developments}

\subsection{Comparison with Other Languages}
\begin{itemize}
\item Rust vs. C++
\end{itemize}


\section{Practical Section}



\section{Conclusion}


\printbibliography


\end{document}
